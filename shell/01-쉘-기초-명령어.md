# 01. 쉘 기초 명령어

# 1.1 echo 명령어

터미널에 문자열을 출력하고 싶다면, echo 명령어를 사용한다. 다음은 예시이다.

```bash
# hello world 출력됨
echo hello world
```

<br/>

만약 `hello                      world` 를 터미널에 출력하고 싶다면 어떻게 할까?

위의 명령어를 입력하면, 여전히 `hello world` 가 나오기 때문에 quote(인용부호)를 이용한다. single quote 또는 double quote 중 하나를 사용하자. 이 둘의 차이는 나중에 다시 다룬다.

```bash
# hello                      world 출력됨
echo "hello                      world"
```

<br/>

비슷한 맥락으로, 2개 이상의 공백을 포함하는 파일명을 만들 때, quote를 사용해야한다.

```bash
touch "hello      world.txt"
```

<br/>

`-n`은 줄바꿈을 처리하지 않고 내용을 그대로 출력한다.(mac에서는 동작하지 않음)

`echo *` 를 실행한다면, 명령어 `ls`와 같은 효과를 볼 수 있다. 현재 경로에서, 존재하는 파일 또는 디렉토리들을 하나의 공백문자로 구분하여, 출력하기 때문에 shell script에서 파일 또는 폴더 처리 할 때 유용하다.

```bash
# Applications Desktop Documents Downloads Library
echo *
```

<br/>

`*`은 **glob**이라고 하며, 현재 경로에 있는 모든 파일 또는 디렉토리가 대상이 된다.

대신 파일이 많을 경우, 가독성이 떨어지기 때문에 터미널에서 현재 경로에 존재하는 파일 또는 디렉토리를 빠르게 확인하고 싶다면,  `ls -alh`를 실행하자.

```bash
# drwxr-xr-x   5 root    admin   160B  4  7 18:49 ..
# drwxr-x---+ 30 user  staff   960B  4 29 15:20 .
ls -alh
```

<br/>

# 1.2 [] 명령어

`[]`은 test 명령어이다. 만약 사용자가 터미널에서 디렉토리 mydir로 이동 후, 파일 Gone With the Wind.mp3가 있는지 알고싶다고 가정하자. 

```bash
cd mydir; [ -f 'Gone With the Wind.mp3' ]
```

<br/>

`;` 은 한 줄에서 2개 이상의 명령어를 입력할 때 사용한다. 명령어의 끝마다 `;`를 입력해주면 된다. `[]` 명령어를 사용할 때, 주의해야할 점은 안에 존재하는 내용들을 공백으로 구분해줘야한다. 예를들어 `-f`가 `[`에 공백없이 붙어있으면 에러가 발생한다.

# 1.3 wc 명령어

명령어 wc는 사용자가 지정한 파일의 행, 단어, 문자 수를 카운트하는 명령어이다.

사용 방법은 `wc -옵션 파일명` 이다. 예를들어 파일 fruits.txt의 내용이 다음과 같다고 하자.

```
grapes
orange
tomato
strawberry
apple
```

<br/>

`wc -w fruits.txt`를 입력하면 파일에 있는 단어의 개수를 출력한다. 여기서는 `\n`  으로 단어가 구분된다. 따라서 5가 출력된다. 이 때 파일명도 같이 출력된다.

`wc -c fruits.txt`를 입력하면, 파일에 있는 문자의 개수를 출력한다. 따라서 39가 출력된다.

`wc -l fruits.txt`를 입력하면, 파일에 있는 라인의 개수를 출력한다. 따라서 5가 출력된다.

`wc -L fruits.txt`은 단어의 길이가 가장 긴 값을 출력한다. 단어 strawberry가 가장 긴 문자열이므로, strawberry에 대한 문자열 길이, 10이 출력된다. (참고로 내 mac에서는 지원이 안되는 옵션이다.)

# 1.4 seq 명령어, tail 명령어

`seq numberA numberB` 을 실행하면 숫자A부터 숫자B까지 연속해서 숫자를 출력한다. `\n`을 기준으로 숫자를 구분한다.

```bash
seq 1 10
1
2
3
4
5
6
7
8
9
10
```

<br/>

만약 출력으로 나온 숫자들을 파일에 저장하고 싶다면, `> 파일명`을 추가로 작성하자.

```bash
seq 1 10 > a.txt
```

<br/>

만약 숫자를 1부터 1,000까지 연속해서 출력하고 이를  파일 a.txt에 저장한다고 했을 때, 마지막 숫자부터 출력하고 싶다고하자. 이 때 명령어 `tail` 를 사용한다.

`tail` 명령어는 기본적으로 마지막 내용부터 시작해서 마지막에서 10번째 까지의 내용을 출력한다.

```bash
tail a.txt
991
992
993
994
995
996
997
998
999
1000 
```

<br/>

만약 10개가 아닌, 사용자가 지정한 개수만큼 보고 싶다면 `-n` 을 사용하면 된다.

```bash
tail -n 5 a.txt
996
997
998
999
1000
```

<br/>

특정 라인의 내용부터 출력하고 싶다면 숫자 앞에 `+` 를 붙인다.

```bash
tail -n +995 a.txt
995
996
997
998
999
1000
```

<br/>

위처럼 특정 라인부터 마지막 라인까지 나오는 것을 확인할 수 있다. 하지만 500번 라인부터 확인하고 싶다면 500번 라인부터 1000번 라인까지 출력되는데, 이는 사용자가 파일의 특정 라인을 확인하는데 어려움이 있게 만든다. 이 문제를 해결하는 방법 중 하나로, `tail`의 출력 결과는 `head` 명령어의 입력으로 넘겨서 특정 라인부분 만큼 출력하게 만드는 것이다. 

`head`는 `tail`과 반대로 마지막 라인이 아닌 처음의 라인부터 출력하는 명령어이다. 그리고 `tail`의 출력 결과를 `head`의 입력으로 넘기기 위해 파이프(`|`)를 사용한다. 지금까지 내용을 바탕으로 명령어를 작성해보자. 사용자가 200번 라인부터 215번라인까지 확인하고 싶을 때, 다음의 명령어를 작성한다.

```bash
tail -n +200 a.txt | head -n 16
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
```

<br/>

참고로 `tail`의 경우, `-f`와 함께 사용하면 실시간 모니터링을 할 수 있는데 주로 시스템 관리자가 로그를 확인 할 때 사용한다.

# 1.5 alias

명령어에 대한 별칭이다. 

```bash
alias mkdir='mkdir -p'
```

<br/>

위와 같이 입력한 후 `mkdir a/b/c/d` 를 입력하면 디렉토리 b가 존재하지 않음에도, 정상적으로 실행되는 것을 확인 할 수 있다. 왜냐하면 `mkdir -p`의 별칭이 `mkdir`이기 때문이다. 이처럼 명령어를 편하게 사용할 수 있는 장점이 있지만, 스크립트 내부에서는 사용할 수 없으며, 인수 또한 넘겨 줄 수 없는 단점이 존재한다.

# 1.6 pushd 명령어, popd 명령어 그리고 cd -

명령어 `pushd` 는 지정한 경로를 스택에 저장하는 명령어이다.

명령어 `popd`는 스택에 존재하는 경로를 pop하여, 해당 경로로 이동하는 명령어이다.

`cd -`를 입력하면 바로 직전에 있었던 경로로 이동하는 명령어이다. `cd -`를 이용하면 현재와 바로 직전의 과거를 왔다갔다 할 수 있다.

# 1.7 printf 명령어

명령어 printf는 우리가 생각하는 기능과 거의 유사하는 역할을한다.(i.e. 문장을 출력하는 명령어)

```bash
# michael jackson 출력됨
name=michael; printf -v legend "%s jackson" $name; echo $legend
```

<br/>

 위처럼 `printf`는 `-v`를 통해 변수 할당도 할 수 있다. 여기서는 michael jackson이 변수 `legend`에 할당됐고, 다음에 수행되는 명령어 `echo`를 통해 해당 변수가 갖고 있는 값이 출력되는 것을 확인할 수 있다.

# 1.8 read 명령어

지금까지 내용을 출력하는 명령어를 학습했다면, 이번에는 내용을 입력으로 받는 명령어를 학습하자.

명령어 `read`는 내용을 입력받아 어딘가에 저장한다. 입력한 내용에 따라, 파일에 저장할 수도, 변수에 저장할 수도 있다. 

 `-p`를 사용한다면, 사용자 입력전, `-p`에 대한 인수가 출력되는 것을 확인할 수 있다. python의 `input()`과 비슷한 역할을 한다고 보면 된다.

```bash
read -p 'are you over 16?' 
```

<br/>

-n은 입력받을 문자의 수를 제한한다. 만약 문자의 수를 1개로 제한한다면, 아래처럼 입력한다.

```bash
read -n 1 -p 'are you over 16?'
```

<br/>

-s는 사용자의 입력이 터미널에서 안보이게 하는 옵션이다. 

```bash
read -s -n 1 -p 'are you over 16?'
```

# 1.9 while do done

프로그래밍 언어에서 while loop를 지원하는 것처럼, shell에서도 사용할 수 있다.

```bash
no=1; while (( no < 10 )); do printf "%02d\n" $no; ((no++)); done
```

<br/>

`while`문에서 명시된 조건이 성립한다면, `do`와 `done`사이에 적힌 내용이 실행된다. 

# 1.10 실행 파일을 실행하는 방법

1. 실행파일에 대한 절대경로를 이용하여 명령어 실행
2. 실행파일을 `/usr/bin`으로 이동시킨 후, 터미널에서 전역적으로 사용
3. 환경변수 `PATH`에 등록하기
4. 실행파일이 있는 경로에서 실행하기